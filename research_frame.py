# research_frame.py

from typing import List
import polars as pl
import numpy as np
import pandas as pd
from IPython.display import display

from queries import format_query
from logs import format_log
from formatting import format_df

class ResearchFrame(pl.DataFrame):
    def __init__(self, *args, **kwargs):
        # print("__init__", *args, kwargs)
        self._logs = kwargs.pop("logs", list())
        super().__init__(*args, **kwargs)

        self.math_functions = {
            "abs"  : lambda x: x.abs(),
            "sqrt"  : lambda x: x.sqrt(),
            "sq": lambda x: x**2,
            "cube"  : lambda x: x**3,
            "log"   : lambda x: x.log(),
            "log10"   : lambda x: x.log10(),
            "exp"   : lambda x: x.exp()
        }


    def __getattribute__(self, name):
        attr = object.__getattribute__(self, name)
        # If the method returns a dataframe, we have to make sure to update the logs
        if callable(attr):
            def wrapper(*args, **kwargs):
                result = attr(*args, **kwargs)
                # This catches both ResearchFrame returns and pl.DataFrame returns from base methods
                if isinstance(result, pl.DataFrame):
                    # Append to the logs
                    logs = object.__getattribute__(self, "_logs") + [(name, (*args, kwargs))]
                    if isinstance(result, ResearchFrame):
                        result._logs = logs
                    else:
                        # Make sure we always return a ResearchFrame instance and not a polars dataframe
                        result = ResearchFrame(result, logs=logs)
                return result
            return wrapper
        else:
            return attr


    # ----------- Core Indexing -----------
    def __getitem__(self, item):
        # print("__getitem__", item, "|")
        # Case 1: Boolean mask as Polars series, Pandas series, or NumPy array
        if isinstance(item, (pl.Series, pd.Series, np.ndarray)) and item.dtype in [bool, pl.Boolean]:
            return self.filter(item)

        # Case 2: Boolean mask as list/tuple
        if isinstance(item, (list, tuple)) and all(isinstance(x, bool) for x in item):
            return self.filter(pl.Series(item))

        # Case 3: List/Array/Series of columns
        if isinstance(item, (list, tuple, pl.Series, pd.Series, np.ndarray)) and all(self._is_column(x) for x in item):
            return ResearchFrame({colname: self.get_column(colname) for colname in item})

        # Case 4: String query expression
        if isinstance(item, str) and not self._is_column(item):
            expr = self._eval_query(item)
            return self.filter(expr)

        # Case 5: Fall back to Polars
        return super().__getitem__(item)


    def _is_column(self, name):
        if not isinstance(name, str):
            return False

        if name in self.columns:
            return True

        # Columns autogenerated for supported Math operations
        underscore_splits = name.split("_")
        if len(underscore_splits) > 1 and underscore_splits[0] in self.math_functions:
            return True

        return False


    def get_column(self, colname):
        if not self._is_column(colname):
            raise AttributeError(f"Column {colname} not found in dataframe!")

        if colname not in self.columns:
            # Autogenerate columns with Math operations specified in the name
            function_name = colname.split("_")[0]
            colname = colname.replace(f"{function_name}_", "")
            return self.math_functions[function_name](self[colname])

        return super().get_column(colname)


    # ----------- Pandas-like Assignment -----------
    def __setitem__(self, key, value):
        # print("__setitem__", key, value, "|")
        # If RHS is a Polars expression, evaluate it first
        if isinstance(value, (pl.Expr)):
            value = self.with_columns(value.alias(key))[key]

        if isinstance(key, str):
            if isinstance(value, (list, tuple, np.ndarray, pd.Series, pl.Series)):
                super().__setitem__([key], np.array([value]).T)

            else:
                super().__setitem__([key], np.array([len(self)*[value]]).T)

        else:
            # Fall back to Polars
            super().__setitem__(key, value)

        # Record change
        self._logs = self._logs + [("SET", (key, {}))]


    def _eval_query(self, query: str) -> pl.Expr:
        if not isinstance(query, str):
            raise TypeError("Query must be a string!")

        expr = format_query(query)
        # print("_eval_query", query, expr)

        # safe eval environment: expose only pl, pl.col, pl.lit, and column-name aliases
        # (already substituted, but exposing mapping is harmless and convenient)
        safe_locals = {name: pl.col(name) for name in self.columns}
        safe_locals.update({"pl": pl, "col": pl.col, "lit": pl.lit})

        try:
            expr = eval(expr, {"__builtins__": {}}, safe_locals)
        except Exception as e:
            raise ValueError(f"Failed to evaluate query\n'{query}':\n{e}")

        if not isinstance(expr, pl.Expr):
            raise ValueError(f"Query did not produce a Polars expression:\n{query!r}")

        return expr


    def find(self, name: str) -> List[str]:
        return [col for col in self.columns if name.lower() in col.lower()]


    def show(self, name: str):
        return self[self.find(name)]


    def __call__(self):
        if self._logs:
            print(format_log(self._logs[-1]))
        display(self)
        return self


    def _repr_html_(self) -> str:
        return format_df(self)


    @property
    def logs(self):
        if not self._logs:
            print("=============== EMPTY LOGS! ===============")
        else:
            print("=============== LOGS ===============")
            padding = len(len(self._logs).__str__())
            for i, log in enumerate(self._logs):
                print(f"STEP {i+1:>{padding}} {format_log(log)}")
